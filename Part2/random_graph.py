"""
Generating a random graph
"""

import random
from graphviz import Graph
dot = Graph(comment='Random graph generated by python')

# number of nodes
nodes = 50
# number of edges
edges = 150

if edges > nodes * (nodes - 1) / 2:
    raise ValueError('The number of edges is too large !')

# in an undirected graph, we dont need to consider the inverse of an edge
all_edges = [{i, j} for i in range(1, nodes + 1) for j in range(i + 1, nodes + 1)]
# remove edges from one node to itself
all_edges = [edge for edge in all_edges if len(edge) == 2]
# shuffle the order of the edges
random.shuffle(all_edges)

# double check that we did not make an error while creating our set of edges
if len(all_edges) == nodes * (nodes - 1) / 2:
    print(f"il y a bien nodes(nodes-1)/2={(nodes * (nodes - 1) / 2)} arÃªtes possibles")

# take edges in the shuffled list of edges
actual_edges = []
for j in range(edges - 1):
    random_edge = all_edges.pop()
    node_a = str(random_edge.pop())
    node_b = str(random_edge.pop())
    actual_edges.append((int(node_a), int(node_b)))

# Get neighbours of each node
neighbours = []
for i in range(1, nodes+1):
    values = [elem for elem in actual_edges if i in elem]
    to_insert = [i, []]
    for elem in values:
        to_insert[1].append(elem[1] if elem[0] == i else elem[0])
    to_insert[1].sort()
    neighbours.append(to_insert)


def part2ColoringProblemHeuristic(nodesAndNeighbors, colors):
    # The heuristic works this way:
    # We sort each node by its degree
    # We go through this list, attributes a color for each node that is not a neighbour with the previous colored node
    # Repeat this process with new colors once we finished going through the list

    colorsAndNodes = dict()
    copyllist = sorted(nodesAndNeighbors, key=lambda x: len(x[1]), reverse=True)
    colorIndex = 0

    while len(copyllist) > 0:
        colorsAndNodes[colors[colorIndex]] = []
        for aNodeAndNeighbors in copyllist:
            if any(x in colorsAndNodes[colors[colorIndex]] for x in aNodeAndNeighbors[1]):
                continue
            else:
                colorsAndNodes[colors[colorIndex]].append(aNodeAndNeighbors[0])
        copyllist = [x for x in copyllist if x[0] not in colorsAndNodes[colors[colorIndex]]]
        colorIndex += 1

    return colorsAndNodes


colors = [
            "red",
            "yellow",
            "blue",
            "green",
            "cyan",
            "purple",
            "orange",
            "magenta",
            "turquoise",
            "grey",
            "pink"
]

to_colour = part2ColoringProblemHeuristic(neighbours, colors)

for color in to_colour:
    for node in to_colour[color]:
        dot.node(str(node), color=str(color), style='filled')

# Colour graph
for each in actual_edges:
    some_color = colors[random.randint(1, len(colors) - 1)]
    some_width = str(random.uniform(1, 2))
    dot.edge(str(each[0]),
             str(each[1]))

# visualize the graph
graph_name = f"graphs/graph"
dot.render(graph_name)

print("graph generated in {}.pdf".format(graph_name))